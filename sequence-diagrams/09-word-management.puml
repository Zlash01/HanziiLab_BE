@startuml Word_Management

title Word Management with Senses and Translations

skinparam sequenceMessageAlign center
skinparam responseMessageBelowArrow true

actor "Admin Client" as Client
participant "WordsController" as WC
participant "WordsService" as WS
participant "WordSensesService" as WSS
participant "WordSenseTranslationsService" as WSTS
database "Database" as DB

== Create Complete Word (with Sense and Translation) ==
Client -> WC: POST /words\n{\n  simplified: "好",\n  traditional: "好",\n  sense: {\n    pinyin: "hǎo",\n    partOfSpeech: "adj",\n    hskLevel: 1,\n    translation: {\n      language: "en",\n      translation: "good"\n    }\n  }\n}
activate WC

WC -> WS: createComplete(createCompleteWordDto)
activate WS

WS -> DB: SELECT * FROM words WHERE simplified = ?
DB --> WS: existingWord | null

alt Word already exists
    WS -> WS: Use existing word
else Word does not exist
    WS -> DB: INSERT INTO words (simplified, traditional)
    DB --> WS: savedWord
end

WS -> WSS: Create word sense
activate WSS

WSS -> DB: SELECT MAX(senseNumber) FROM word_senses WHERE wordId = ?
DB --> WSS: maxSenseNumber
WSS -> WSS: senseNumber = maxSenseNumber + 1

WSS -> DB: INSERT INTO word_senses\n(wordId, senseNumber, pinyin, partOfSpeech, hskLevel, isPrimary)
DB --> WSS: savedSense

WSS --> WS: wordSense
deactivate WSS

opt translation provided
    WS -> WSTS: Create translation
    activate WSTS
    
    WSTS -> DB: INSERT INTO word_sense_translations\n(wordSenseId, language, translation, additionalDetail)
    DB --> WSTS: savedTranslation
    
    WSTS --> WS: translation
    deactivate WSTS
end

WS -> DB: SELECT word with senses and translations (full reload)
DB --> WS: completeWord

WS --> WC: Word with senses and translations
deactivate WS
WC --> Client: 201 Created\n{ id, simplified, senses: [...] }
deactivate WC

== Search Word by Simplified ==
Client -> WC: GET /words/search?simplified=你好
activate WC

WC -> WS: search(simplified)
activate WS

WS -> DB: SELECT * FROM words\nWHERE simplified LIKE '%你好%'\nLEFT JOIN word_senses, word_sense_translations
DB --> WS: words[]

WS --> WC: words[]
deactivate WS
WC --> Client: 200 OK\n[{ word with senses }]
deactivate WC

== Get Word by Simplified (User Access) ==
Client -> WC: GET /words/simplified/好
activate WC

WC -> WS: findBySimplified(simplified)
activate WS

WS -> DB: SELECT * FROM words\nWHERE simplified = '好'\nJOIN word_senses, word_sense_translations
DB --> WS: word | null

alt Word not found
    WS --> WC: NotFoundException
    WC --> Client: 404 Not Found
else Word found
    WS --> WC: word with senses
    deactivate WS
    WC --> Client: 200 OK\n{ word data }
end
deactivate WC

== Add Translation to Word Sense ==
Client -> WC: POST /word-senses/:senseId/translations\n{ language: "vn", translation: "tốt" }
activate WC

WC -> WSTS: create(senseId, createTranslationDto)
activate WSTS

WSTS -> DB: SELECT * FROM word_senses WHERE id = ?
DB --> WSTS: sense | null

alt Sense not found
    WSTS --> WC: NotFoundException
    WC --> Client: 404 Not Found
else Sense exists
    WSTS -> DB: SELECT * FROM word_sense_translations\nWHERE wordSenseId = ? AND language = ?
    DB --> WSTS: existing | null
    
    alt Translation exists for language
        WSTS --> WC: ConflictException\n"Translation already exists"
        WC --> Client: 409 Conflict
    else New translation
        WSTS -> DB: INSERT INTO word_sense_translations
        DB --> WSTS: savedTranslation
        
        WSTS --> WC: translation
        deactivate WSTS
        WC --> Client: 201 Created\n{ translation data }
    end
end
deactivate WC

== Get Word Statistics (Admin) ==
Client -> WC: GET /words/stats
activate WC

WC -> WS: getWordStats()
activate WS

WS -> DB: SELECT COUNT(*) as total FROM words
WS -> DB: SELECT hskLevel, COUNT(*) FROM word_senses GROUP BY hskLevel
WS -> DB: SELECT language, COUNT(*) FROM word_sense_translations GROUP BY language
DB --> WS: stats data

WS --> WC: WordStatsDto
deactivate WS
WC --> Client: 200 OK\n{ totalWords, byHskLevel, byLanguage }
deactivate WC

@enduml
